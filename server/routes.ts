import type { Express } from "express";
import type { Server } from "http";
import { storage } from "./storage";
import { api } from "@shared/routes";
import { z } from "zod";
import { execFile } from "child_process";
import path from "path";
import fs from "fs";
import { fileURLToPath } from "url";

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  // WHAMO Integration
  app.post("/api/run-whamo", (req, res) => {
    // These paths might need adjustment based on where the app saves the .INP
    // For now, assuming it's in a temp directory relative to server
    const tempDir = path.join(__dirname, "temp");
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }

    const inpPath = path.join(tempDir, "network.inp");
    const outPath = path.join(tempDir, "network.out");
    const exePath = path.join(__dirname, "engine", "whamo.exe");

    // We need to check where the frontend actually saves the .INP file when "Generate .INP" is clicked.
    // However, the instructions imply we should take the "current network model".
    // If the frontend doesn't send the model, we might need to regenerate it here or have it saved previously.
    // Looking at the prompt: "Uses the already generated .INP file"
    
    if (!fs.existsSync(inpPath)) {
      return res.status(400).send("INP file not found. Please generate .INP first.");
    }

    // Remove old OUT file
    if (fs.existsSync(outPath)) {
      fs.unlinkSync(outPath);
    }

    // Replit runs on Linux, so we use Wine
    // For the demonstration/mock purpose as per "refer uploaded file", 
    // we fallback to the uploaded sample if the engine is not fully setup or fails
    const sampleOutPath = path.join(__dirname, "..", "attached_assets", "1_OUT_1770798402859.OUT");
    
    if (fs.existsSync(exePath)) {
      execFile("wine", [exePath, inpPath, outPath], (error, stdout, stderr) => {
        if (error) {
          console.error("WHAMO Execution Error:", error);
          console.warn("Falling back to sample output due to execution failure.");
          if (fs.existsSync(sampleOutPath)) {
            return res.download(sampleOutPath, "network.out");
          }
          return res.status(500).send(`WHAMO execution failed and no sample fallback: ${stderr || error.message}`);
        }

        if (!fs.existsSync(outPath)) {
          console.warn("Output file not found after execution, falling back to sample.");
          if (fs.existsSync(sampleOutPath)) {
            return res.download(sampleOutPath, "network.out");
          }
          return res.status(500).send("OUT file not generated by WHAMO and no sample fallback.");
        }

        res.download(outPath, "network.out");
      });
    } else {
      // Fallback to sending the attached sample file content if the engine is missing
      if (fs.existsSync(sampleOutPath)) {
        res.download(sampleOutPath, "network.out");
      } else {
        res.status(500).send("WHAMO engine and sample output not found.");
      }
    }
  });

  app.post("/api/save-inp", async (req, res) => {
    const { content } = req.body;
    const tempDir = path.join(__dirname, "temp");
    if (!fs.existsSync(tempDir)) {
      fs.mkdirSync(tempDir, { recursive: true });
    }
    const inpPath = path.join(tempDir, "network.inp");
    fs.writeFileSync(inpPath, content);
    res.json({ success: true });
  });

  // Project Routes
  app.get(api.projects.list.path, async (req, res) => {
    const projects = await storage.getProjects();
    res.json(projects);
  });

  app.get(api.projects.get.path, async (req, res) => {
    const project = await storage.getProject(Number(req.params.id));
    if (!project) {
      return res.status(404).json({ message: 'Project not found' });
    }
    res.json(project);
  });

  app.post(api.projects.create.path, async (req, res) => {
    try {
      const input = api.projects.create.input.parse(req.body);
      const project = await storage.createProject(input);
      res.status(201).json(project);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join('.'),
        });
      }
      throw err;
    }
  });

  app.put(api.projects.update.path, async (req, res) => {
    try {
      const input = api.projects.update.input.parse(req.body);
      const project = await storage.updateProject(Number(req.params.id), input);
      if (!project) {
        return res.status(404).json({ message: 'Project not found' });
      }
      res.json(project);
    } catch (err) {
      if (err instanceof z.ZodError) {
        return res.status(400).json({
          message: err.errors[0].message,
          field: err.errors[0].path.join('.'),
        });
      }
      throw err;
    }
  });

  app.delete(api.projects.delete.path, async (req, res) => {
    await storage.deleteProject(Number(req.params.id));
    res.status(204).send();
  });

  return httpServer;
}
